#!/usr/bin/env python

# A zeroth level classifier system based on Wilson's paper 'ZCS: A
# Zeroth Level Classifier System' (http://www.eskimo.com/~wilson/ps/zcs.pdf).
# Some options like world, startposition can be configured. To increase
# the detailed output play with the verbose variable, 3 would be a good
# value to test your algorithm modifications.
# The amount of attempts per connection will be printed to stdout.
# 26.11.12 M. Bittorf <info@coding-minds.com>

import random
import socket
import sys
import re
import time
import math
from operator import itemgetter, attrgetter
from itertools import groupby

## Test environment configuration
host = 'localhost'
port = 4567

world = '' # without <>
startposition = '' # 'x y'

iterations = 10 # -1 = infinite
ignore_failed_iterations = True

verbose = 0 # 0 - 5 / 10
sleep = 0 # seconds
reconnect_after_fitness = True # experimental ! (verbose: min 3)
ignore_repetitions = False

## ZCS configuration from Wilson (1994)
# N     Population size.
# P     Probability of a # at an allele position in the condition of a classifier created through covering, and in the conditions of classifiers in the initial randomly generated population.
# S0    Strength assigned to each classifier in the initial population.
# Beta  Learning rate for strength updates under the bucket brigade.
# Gamma Discount factor for the bucket brigade.
# Tau   Fraction of strength deducted from classifiers in [M] - [A].
# Chi   Probability of crossover per invocation of the GA. 
# My    Probability of mutation per allele in an offspring. Mutation takes 0,1, # equiprobably into one of the other allowed alleles.
# Rho   Average number of new classifiers generated by the GA per time-step of the performance cycle.
# Phi   If the total strength of [M] is less than Phi times the mean strength of [P], covering occurs.

N = 400
P = 0.33
S0 = 20.0
Beta = 0.2
Gamma = 0.71
Tau = 0.1
Chi = 0.5
My = 0.002
Rho = 0.25
Phi = 0.5

####### -- don't touch if you don't known what are you doing -- #######

## static stuff
representation = [".", "N", "NO", "O", "SO", "S", "SW", "W", "NW"]
possible_inputs = [".", "F", "O"]
possible_alleles = [".", "F", "O", "#"]

## function definitions

# returns a classifier from the given population. If the second
# parameter is false it will use the inverse of the strength
def roulette_wheel(pop, inverse=False):
	wheel = list()
	
	if inverse:
		max = 0
		for condition, action, strength in pop:
			if strength > max:
				max = strength
		for condition, action, strength in pop:
			wheel += [ (condition, action, strength) for i in range(int(math.floor(max) - math.ceil(strength))) ]
	else:
		for condition, action, strength in pop:
			wheel += [ (condition, action, strength) for i in range(int(math.ceil(strength))) ]
	
	if len(wheel) > 0:
		return wheel[random.randint(0,len(wheel)-1)]
	else:
		return False

# add a classifier to classifier_list, merge with an already existing one and remove another one
def add_classifier((condition, action, strength)):
	global classifier_list
	
	classifiers = filter(lambda (c, a, s): c == condition and a == action, classifier_list)
	
	if len(classifiers) > 1:
		print >> sys.stder, "datastructure corrupted !"
		sus.exit()
	
	if len(classifiers) > 0:
		fixed_strength = sum(map(lambda (c, a, s): s, classifiers)) + strength
		for classifier in classifiers:
			classifier_list.remove(classifier)
		classifier_list.append((condition, action, fixed_strength))
	else:
		classifier = roulette_wheel(classifier_list, True)
		if classifier:
			classifier_list.remove(classifier)
		
		classifier_list.append((condition, action, strength))
	
	

# set #'s based on P for environ
def place_wildcards(environ):
	environ_list = list(environ)
	for i in range(0, len(environ_list)):
		if random.random() <= P:
			environ_list[i] = "#"
	
	return ''.join(environ_list)

# create a completely new random classifier
def spawn_classifier():
	condition = place_wildcards(''.join([ possible_inputs[random.randint(0,len(possible_inputs)-1)] for i in range(0,8) ]))
	
	# cast of dice
	action = random.randint(1,8)
	
	return condition, action, S0

# creates a new classifier based on the input values environ and
# strength and insert it into the classifier population
def new_classifier(environ="random", strength=S0):
	global classifier_list
	# cast of dice
	action = random.randint(1,8)
	
	if "random" == environ:
		environ = spawn_classifier()
	else:
		environ = place_wildcards(environ)
	
	add_classifier((environ, action, strength))
	
	return environ, action, strength

# create a new random population with classifiers
def init_classifiers():
	return [ spawn_classifier() for X in range(N) ]

# return true if the given condition matches the given environ
def is_match(condition, environ):
	for i in range(0, len(environ)):
		if "#" == condition[i]:
			continue
		if condition[i] != environ[i]:
			return False
	return True

# return a matchingset for the given environ. if not possible create a
# new classifier, add them to the population and create a matchingset
# with this one.
def get_matchingset(environ):
	global classifier_list
	
	match = list()
	
	for (condition, action, strength) in classifier_list:
		if is_match(condition, environ):
			match.append((condition, action, strength))
	
	if len(match) > 0:
		# if total strength in [M], is less than a fraction Phi of the
		# population mean strength create a new classifier.
		SM = sum(map(lambda (c, a, s): s, match))
		MSP = sum(map(lambda (c, a, s): s, classifier_list)) / len(classifier_list)
		if SM < (Phi * MSP):
			match = [new_classifier(environ, MSP)]
		return match
	
	return [new_classifier(environ)]

# apply the function fun to the strength of a population and synchronise
# these changes to the classifier_list
def change_strength(fun, pop):
	global classifier_list
	
	for condition, action, strength in pop:
		if (condition, action, strength) in classifier_list:
			classifier_list.remove((condition, action, strength))
			classifier_list.append((condition, action, fun(strength)))
		else:
			classifiers = filter(lambda (c, a, s): c == condition and a == action, classifier_list)
			if len(classifiers) < 1: # if some old references occure
				continue
			
			for (condition, action, strength) in classifiers:
				classifier_list.remove((condition, action, strength))
			
			fixed_strength = sum(map(lambda (c, a, s): s, classifiers))
			classifier_list.append((condition, action, fun(fixed_strength)))
	
	return map(lambda (c, a, s): (c, a, fun(s)), pop)

# the genetic algorithm
def run_ga():
	global classifier_list
	
	(conditionA, actionA, strengthA) = classifierA = roulette_wheel(classifier_list)
	(conditionB, actionB, strengthB) = classifierB = roulette_wheel([ c for c in classifier_list if c != classifierA ])
	
	# deduct parent strength
	change_strength(lambda strength: strength * 0.5, [classifierA])
	change_strength(lambda strength: strength * 0.5, [classifierB])
	
	# crossover
	if random.random() <= Chi:
		pos = random.randint(0, len(conditionA))
		conditionA_new = conditionA[:pos] + conditionB[pos:]
		conditionB = conditionB[:pos] + conditionA[pos:]
		conditionA = conditionA_new
		
		strengthA = strengthB = (strengthA + strengthB) / 4
	
	# mutation
	conditon_listA = list(conditionA)
	conditon_listB = list(conditionB)
	for i in range(0, len(conditon_listA)):
		if random.random() <= My:
			conditon_listA[i] = random.choice([ a for a in possible_alleles if a != conditon_listA[i] ])
		if random.random() <= My:
			conditon_listB[i] = random.choice([ a for a in possible_alleles if a != conditon_listB[i] ])
		
	# append new
	add_classifier((''.join(conditon_listA), actionA, strengthA))
	add_classifier((''.join(conditon_listB), actionB, strengthB))

## global data
classifier_list = init_classifiers()
last_classifiers = list() # of tuples

## enter the challenge
while -1 == iterations or iterations > 0:
	if 0 < iterations:
		iterations-=1
	
	# create an INET, STREAMing socket
	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	except socket.error, msg:
		print >> sys.stderr, "Failed to create socket. Error code: "
		+ str(msg[0]) + " , Error message : " + msg[1]
		sys.exit()
	
	# resolve
	try:
		remote_ip = socket.gethostbyname( host )
	except socket.gaierror:
		print >> sys.stderr, 'Hostname could not be resolved. Exiting'
		sys.exit()

	# connect and receive greeting
	s.connect((host, port))
	s.recv(1024)
	
	# try to load a world
	try:
		data = ""
		found = 0
		
		# request world list
		s.sendall("world list\r\n")
		if 10 <= verbose:
			print "world list"
		while "EOL" not in data: # until end of list
			data = s.recv(1024) # read world list
			
			# are you debugging smthg ?
			if 10 <= verbose:
				print data
			
			# extract all worlds
			match = re.findall(' <(.+?)> ', data)
			
			# prepend configured world if set
			if world:
				match.insert(0, world)
			
			# is there a world ?
			if not match:
				break
			
			# try to load one of the worlds
			for w in match:
				if 2 <= verbose:
					print "try world <" + w + "> " + startposition
				if startposition:
					s.sendall("world load <" + w + "> " + startposition + "\r\n")
					# are you debugging smthg ?
					if 10 <= verbose:
						print "world load <" + w + "> " + startposition
				else:
					s.sendall("world load <" + w + ">\r\n")
					# are you debugging smthg ?
					if 10 <= verbose:
						print "world load <" + w + ">"
				
				sdata = s.recv(1024)
				
				# are you debugging smthg ?
				if 10 <= verbose:
					print sdata
				
				if "200" in sdata: # great. world is available
					found = 1
					print >> sys.stderr, "Use world <" + w + ">."
					break
		
		# no world available oder usable
		if not found:
			print >> sys.stderr, "No world available."
			s.close()
			sys.exit()
	# smthg bad hapend. fix it !
	except socket.error, msg:
		print >> sys.stderr, "Failed to communicate with server while loading world."
		print >> sys.stderr, "Still", iterations, "iterations pending."
		print >> sys.stderr, "Cleanup and start next try."
		classifier_list = init_classifiers()
		last_classifiers = list() # of tuples
		if ignore_failed_iterations:
			iterations+=1
		continue

	# go and search food
	try:
		data = ""
		counter = 0
		
		# get initial environ
		s.sendall("environ\r\n")
		data = s.recv(1024)
		
		# are you debugging smthg ?
		if 10 <= verbose:
			print "environ"
			print data
		
		# cleanup environ
		data = ''.join(re.findall('[0-9]+:[\.FO*]+', data))
		
		while 1:
			# run the GA
			if Rho > 0 and (counter * Rho) % 2 == 0:
				run_ga()
			
			# separate fitness and environ
			fitness, sep, env = data.partition(":")
			
			# are you curious ?
			if 4 <= verbose:
				print fitness, env
			
			# get matchingset
			M = get_matchingset(env)
			
			# get classifier
			condition, action, strength = roulette_wheel(M)
			
			# get actionset
			A = filter(lambda (c, a, s): a == action, M)
			
			# deducted fraction of strength from classifiers in [M] - [A].
			change_strength(lambda strength: (1.0-Tau)*strength, [ c for c in M if c not in A ])
			
			# deduct fraction Beta from the strength of each member of A and
			# place it in bucket B
			B = sum(map(lambda (c, a, s): Beta * s, A))
			A = change_strength(lambda strength: (1.0-Beta)*strength, A)
			
			# do it !
			s.sendall("move " + str(action) + "\r\n")
			data = s.recv(1024)
			counter+=1
			
			# are you debugging smthg ?
			if 10 <= verbose:
				print "move " + str(action)
				print data
			
			# are you curious ?
			if 5 <= verbose:
				print representation[action]
			
			# get new environ string if missing
			while not ":" in data:
				s.sendall("environ\r\n")
				data = s.recv(1024)
				
				# are you debugging smthg ?
				if 10 <= verbose:
					print "environ"
					print data
			
			# cleanup environ and separate fitness and environ
			data = ''.join(re.findall('[0-9]+:[\.FO*]+', data))
			fitness, sep, env = data.partition(":")
			
			# add a quantity of the reward to the strength of each classifier
			# in A
			if int(fitness) > 0:
				fraction = Beta * int(fitness) / len(A)
				A = change_strength(lambda strength: strength + fraction, A)
			
			# increment the strength of each classifier in A-1 with a fraction
			# of B
			if len(last_classifiers) > 0 and len(last_classifiers[-1]) > 0:
				fraction = Gamma * B / len(last_classifiers[-1])
				last_classifiers[-1] = change_strength(lambda strength: strength + fraction, last_classifiers[-1])
			
			# remember, remember, ..
			if ignore_repetitions and len(last_classifiers) > 0:
				(last_c, last_a, last_s) = last_classifiers[-1][0]
				if last_c != condition and last_a != action:
					last_classifiers.append(A)
			else:
				last_classifiers.append(A)
			
			# task done ?
			if int(fitness) > 0 and reconnect_after_fitness:
				break
			
			# should we pause a while ?
			if sleep:
				time.sleep(sleep)
		
		print counter
	# smthg bad happend. fix it !
	except socket.error, msg:
		print >> sys.stderr, "Failed to communicate with server while searching food."
		print >> sys.stderr, "Still", iterations, "iterations pending, this was guess", counter
		print >> sys.stderr, "Cleanup and start next try."
		classifier_list = init_classifiers()
		last_classifiers = list() # of tuples
		if ignore_failed_iterations:
			iterations+=1
		continue
	
# close connection
	s.close()

# wanna see the results ?
if verbose:
	classifier_list.sort(key=itemgetter(2), reverse=True)
	for condition, action, quality in classifier_list:
		print condition, "\t", action, "\t", quality
